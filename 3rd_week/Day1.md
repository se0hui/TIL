# 빌드 도구 / 디렉토리 구조

## 빌드 도구

정의: 빌드도구는 소스코프에서 어플리케이션 생성을 자동화 하기 위한 프로그램이다. 빌드는 코드를 사용 또는 실행 가능한 형태로 컴파일링, 링킹, 패키징 하는 것을 포함한다.

기본적으로 빌드 자동화는 아래와 같은 정형화된 다양한 작업을 스크립팅 하거나 자동화하는 행위이다.

1. 중속성 다운로드
2. 소스코드를 바이너리코드로 컴파일
3. 바이너리 코드를 패키징
4. 테스트 실행
5. 프로덕션 시스템에 배포

**빌드 도구를 사용하는 이유:**

대규모 프로젝트에선 빌드프로세스 수동 호출이 실용적이지 않다.
무엇을 빌드할지, 어떤 순서로 할지, 어떤 의존성이 있는지 모두 추적하기 쉽지 않기 때문이다. 빌드 도구를 사용하면 이를 일관되게 할 수 있다

종류:

1. 앤트

    > 이클립스에 기본적으로 탑재되었으며, XML 스크립트를 기반으로 한 빌드 도구
    라이브러리를 자동적으로 업데이트 하는 기능이 없어 레거시 시스템에서만 사용되고 있음

   - [x] 레거시 시스템: 낡은 기술이나 방법론, 컴퓨터 시스템, 소프트웨어 등을 말한다. 현대까지도 남아 쓰이는 기술을 의미할 수도 있지만, 더 이상 쓰이지 않더라도 현대의 기술에 영향을 주는 경우도 포함한다.

<br>

1. 메이븐

    > 앤트 이후에 나온 자바 빌드 도구
    **라이브러리 및 의존 관리 기능**: 앤트로 불가능했던 라이브러리, 의존성 관리 기능을 가능하게 함.
    **XML 스크립트 기반 관리**: 'pom.xml'파일을 사용하여 의존성을 관리함
    **라이프 사이클 개념 도입**: 업데이트를 통해 라이프 사이클 개념이 도입되었고, 빌드 순서와 같은 프로세스를 정의할 수 있어 빌드 과정이 체계적으로 관리 됨
    **개발자 커뮤니티와 레퍼런스**: 가장 많은 사용자가 사용하는 빌드 도구이며, 다양한 레퍼런스가 존재해 문제 해결과 학습이 용이함

<br>

3. 그레이들
    > 가장 최근에 나온 자바 빌드 도구
    **그루비 문법과 관리의 용이성**: Gradle은 그루비 문법을 사용하고, 스크립트를 'build.gradle'파일에 작성함
    XML 기반 스크립트에 비해 관리가 편리하여 대규모 프로젝트에서 유리함
    **안드로이드 표준 빌드 시스템**: 안드로이드 프로젝트의 표준 빌드 시스템으로 채택되어 널리 사용되고 있음

<br><br>

### Gradle & Maven

**Maven의 장점**

- 다양한 관련 레퍼런스
  - 스프링 부트 프로젝트 고나련 검색 필요 시, Maven 빌드 관련 프로젝트가 압도적으로 많다.
- 수많은 사용자 경험
  - Maven이 더 오래 되었기 때문에 다양한 사용자 경험이 존재한다.
- 개발 가이드 라인 제공
  - 정형화된 가이드 라인이 잘 정리 되어 있다.

<br>

**Gradle의 장점**

- **간결한 스크립트**
  - 프로젝트의 규모가 커질 수록 XML 파일의 복잡도가 커지는데, 이에 반해 간결한 스크립트로 실행된다.
- 빌드 속도
  - Gradle은 캐싱을 하기 때문에 Ant나 Maven 같은 이번 빌드 도구보다 빌드 속도가 빠르다.
- **멀티 프로젝트 빌드**
  - 대규모 자바 프로젝트는 대부분 다중 모듈로 구성되며, Gradle의 멀티 프로젝트 빌드 기능을 이용하면 번거로움과 실수를 줄일 수 있다.
  - 필요에 따라 개별적으로 설정할 수 있어 스크립트 작성량이 메이븐보다 적다.
- **Wrapper**
  - 초기 세팅 시 Gradle Wrapper 사용을 권하며, 특정 버전의 Java나 Gradle을 설치할 필요없이 바로 프로젝트를 실행할 수 있다.

<br><br>

## 디렉토리 구조

**디렉토리**: 파일 시스템 내부에 있는 특수한 형태의 파일, 효율적인 파일 사용을 위해 디스크에 존재하는 파일에 대한 여러 정보를 관리한다.

디렉토리는 각 파일의 위치, 크기, 할당 방식, 형태, 소유자, 계정 정보 등의 정보를 가지고 있다.

**디렉토리 구조**: 파일 시스템에서 파일과 디렉토리를 체계적으로 구성하는 방식이다. 디렉토리 구조는 파일의 위치, 크기, 할당 방식, 등을 관리하며, 효율적인 파일 사용과 관리를 돕는다.

디렉토리 구조는 계층적 트리 형태로 구성되며, 루트 디렉토리를 시작으로 하위 디렉토리와 파일들이 포함된다.

**기능**:

1. Search (파일 찾기)
2. Create (파일 생성)
3. Delete (파일 삭제)
4. List (디렉토리 나열)
5. Rename (파일 이름 수정)
6. Traverse (파일 시스템 순회)

**구성**:

- Efficiency: 디렉토리는 파일을 빠르게 탐색할 수 있어야 한다.
- Naming: 적절한 이름으로 사용자들이 편리하게 사용할 수 있으면 좋을 것이다.
- Grouping: 파일들을 적절한 분류로 그룹화 해두면 사용하기 편리할 것이다. 이를 위해 디렉토리의 논리적 구조를 정의하는 여러 방법이 있다.

### Single Level Detectory

![image.png](https://velog.velcdn.com/images/lcheun/post/63f4c706-9311-4356-b4c9-5a3b76a101a9/image.png)

- **단순한 구조의 장단점**
  - 모든 파일들이 하나의 디렉토리 밑에 존재하여, 이해가 용이하지만, 파일이 많아지면 관리가 어려워진다.
  - 다수의 사용자가 사용하는 시스템에서는 문제 발생이 가능하다.

- Nameing Problem
  - 파일들은 서로 유일한 이름을 가져야 하며, 서로 다른 사용자라도 같은 이름의 파일을 사용할 수 없다.

- Grouping Problem
  - 시스템에 오직 아나의 디렉토리만 있어 그룹화가 불가능 하며, 파일을 논리적으로 묶는 것이 불가능하여 관리가 어렵다.

### Two Level Directory

 ![image.png](https://velog.velcdn.com/images/lcheun/post/ab4f7935-a1ef-4808-a519-58f59776f17b/image.png)

- **2단계 디렉토리 구조**
  - 중앙에 마스터 파일 디렉토리(MFD)가 있고, 그 아래 사용자별 파일 디렉토리(UFD)가 있는 2계층 구조이다.
  - MFD는 각 사용자들의 이름이나 계정 번호, 사용자 파일 디렉토리를 가리키는 포인터를 갖고 있다.
- **UFD 관리**
  - UFD는 각 사용자의 파일들에 대한 정보를 관리하며, 각 사용자는 자신의 UFD 내에서만 유일한 파일 이름을 사용해야 한다.
  - 서로 다른 UFD에서는 동일한 파일 이름을 사용할 수 있다.
- **협력 및 공유의 어려움**
  - 각 사용자는 다른 사용자의 파일 디렉토리를 검색할 수 없으며, 업무 협력 및 파일 공유가 어렵다.
- **파일 이름 지정 및 Grouping 문제**
  - 파일을 저장할 때 사용자 이름과 파일 이름을 함께 지정해야하기에 파일 이름이 길어진다.
  - Grouping 기능이 존재하지 않는다.

### Tree Structured Directories

![image.png](https://velog.velcdn.com/images/lcheun/post/edb6aa97-eb17-42c5-b4e9-6a1819451f74/image.png)

- **트리 디렉토리 구조**
  - 하나의 루트 디렉토리와 여러 개의 서브 디렉토리로 구성된다.
  - 사용자들은 자신의 서브 디렉토리를 만들어 파일을 구성할 수 있고, 각 사용자는 하나의 루트 디렉토리를 가진다.
  - 모든 파일은 고유한 경로를 가진다.
- **운영체제 및 파일 관리**
  - DOS, Windows, UNIX 등의 운영체제에서 사용된느 디렉토리 구조.
  - 서로 다른 디렉토리 내에 동일한 이름의 파일, 디렉토리를 생성할 수 있다.
  - 디렉토리의 생성, 파괴가 비교적 용이하다.
- **경로명과 탐색 방법**
  - 디렉토리 탐색은 포인터를 사용하며, 경로명은 절대 경로명과 상대 경로명을 사용하며, 해당 경로를 통해 효율적인 탐색 및 그룹화가 가능하다.
  - 절대 경로: 루트부터 현재 파일 위치까지 포함하는 전체 경로
  - 상대 경로: 현재 위치를 기준으로 목적지까지의 상대적인 경로
- **파일과 디렉토리 구분**
  - 일반 파일과 디렉토리는 비트를 사용하여 구분한다.(0: 일반파일, 1: 디렉토리)

